第二章
js推荐使用外部文件的理由：
    1、可维护性
    2、缓存：不同HTML使用同一js文件只需要下载一次
    3、适应未来
以轻量、独立的JS组件形式向客户端送达脚本更具优势：
    1、与大文件相比，获取资源延迟差不多
    2、将大文件切割为轻量可缓存的小文件，复用性更强
可以使用defer属性把脚本推迟到文档渲染完毕后再执行，推迟的脚本原则上按照它们被列出的次序执行
可以使用async属性表示脚本不需要等待其它脚本，同时也不阻塞文档渲染，即异步加载，异步加载脚本不能保证它们在页面中出现的次序执行

第三章
    语法
    1、区分大小写
    2、标识符
    3、注释
    4、严格模式
        -对于不规范写法在该模式下会被处理，对于不安全的活动将抛出错误
        启用方式：
            ①在脚本开头加上 "use strict"
            ②单独指定一个函数将上面指令直接放在函数体开头
    5、语句
关键字
变量
    1、var关键字
        不推荐改变变量保存值的类型但是有效
        （1）作用域：
            使用var在函数中声明的变量会变成它的函数局部变量
            在函数内声明时忽略var则是创建一个全局变量
        （2）var声明提升
            即把所有变量都拉到函数作用域的顶部
    2、let声明
        let声明的范围是块作用域
        （1）暂时性死区：let声明的变量不会在作用域中被提升，将let声明前的执行瞬间成为“暂时性死区”
        （2）全局声明：使用let在全局作用域下声明的变量不会成为window的属性（var声明的会）
        （3）条件声明：let不能依赖条件声明模式
        （4）for循环的let声明
    3、const声明
        必须初始化变量且声明的变量不允许修改，否则会报错，也不允许重复声明；但是如果声明的是一个对象，那么可以修改该对象内部的属性
        const不能用来声明迭代变量（因为迭代变量会自增）
    4、声明风格及最佳实践
        （1）不使用var
        （2）const优先，let次之
数据类型
    -6种原始数据类型：Undefined、Null、Boolean、Number、String、Symbol(ES6添加的)
    -1种复杂数据类型：Object
    1、typeof操作符（可以确定function）
        特殊值null被认为是一个对空对象的引用
    2、Undefined类型
        （1）包含undefined值的变量跟未定义变量是有区别的
        （2）上面的两种变量在typeof中返回的都是undefined
    3、Null类型
        undefined值是由null值派生来的所以在表面上（==时）两者相等
    4、boolean类型
    5、Number类型    ​
        Number类型最基本的数值字面量格式就是十进制整数
        整数也可以使用八进制或十六进制字面量表示，对于八进制字面量第一个数字必须是0，然后是对应的八进制数字；十六进制则是在加上数字前缀0x，然后是十六进制数字。
            浮点值
                由于存储浮点值使用的内存空间时存储整数值的两倍，所以ECMAScript总是会想方设法把值转换为整数，在小数点后没有数字的情况下，数值就会变成整数。
                对于特别大或特别小的数值，可以使用科学记数法表示：
                数值后面加e再加上要乘的10的多少次幂
                注：永远不要测试某个特定的浮点值，如测试0.1+0.2是否等于0.3

            值的范围
                使用Number.MIN_VALUE/Number.MAX_VALUE可以查看ECMAScript可以表示的最小值/最大值
                使用isFinite()函数可以确定一个值是否为有限大
            
            NaN
                NaN意思是“不是数值”，用于表示本来要返回的数值操作失败了（而不是抛出错误）。
                0、+0、-0相除都会返回NaN
                如果分子是非0值，分母是有符号0或无符号0，会返回Infinity或-Infinity
                独有属性
                任何涉及NaN的操作始终返回NaN。
                NaN不等于包括NaN在内的任何值。
                isNaN()函数可以判断一个值是否“不是数值”，其他类型的值会直接转换为数值。任何不能转换为数值的值都会导致这个函数返回true。
            
            数值转换
                Number()：
                    布尔值：true返回1、false返回0
                    数值直接返回
                    null返回0
                    undefined返回NaN
                    字符串：
                    字符串包含数值字符，则转换为一个十进制值
                    字符串包含有效的浮点值格式，则转换为相应的浮点值
                    字符串包含有效的十六进制，则转换为与该十六进制对应的十进制整数
                    字符串为空字符串，则返回0
                    字符串包含其他情况的字符则返回0
                    对象：调用Valueof()方法，并按照上述规则返回值。如果转换结果是NaN，则调用toString()方法，再按照转换字符串的规则转换。
               
                parseInt()：
                    parseInt()也可以得到整数，它更专注于字符串中是否包含数值模式，会从字符串第一个非空格字符开始转换，如果不是数值字符、加号或减号则返回NaN，如果是数值符号、加号或减号则继续依次检测每个字符直到字符串末尾，或遇到非数值字符。
                    parseInt()可以识别不同进制的整数格式，也可以接收第二个参数指定进制数。

                parsFloat()：
                    parsFloat()函数的工作方式与parseInt()类似，都是从位置0开始检测每个字符，解析到字符串末尾或者解析到一个无效的浮点数值字符为止，这意味着第一次出现的小数点是有效的但第二次出现的小数点是无效的，此时字符串中剩余字符都会被忽略。
                    注：parseInt()只解析十进制值，因此不能指定底数。
​
        （5）string类型
            把一个值转换为字符串：
                ①toString()：
                    -null与undefined值没有toString方法
                    -对数值调用时括号中可以接受一个参数表示以什么底数来输出数值的字符串表示
                ②String()：
                    -null与undefined也可以使用该方法
            模板字符串（``）：会保持反引号中的空格
                使用模板字符串插值:标签函数会被接收到的参数依次是原始字符串数组和每个表达式求值的结果。
            原始字符串：使用String.raw标签函数可以直接获取原始的模板字面量内容
        （6）Symbol类型(符号)
            -唯一性：符号实例是唯一的、不可变的
            -基本用法：
                ①使用Symbol()初始化，可以传入一个字符串参数作为对符号的描述，与函数定义或表示完全无关
                ②没有字面量语法
            -使用全局符号注册表
                使用Symbol.for()方法：调用时会检查全局运行时注册表，发现不存在则生成一个新符号实例并添加进注册表中，如果存在则返回该符号实例
                使用Symbol.keyfor()方法:查询全局注册表，返回该全局符号对应的字符串键，如果不存在则返回undefined
            -使用符号作为对象属性
                Object.getOwnPropertyNames()返回对象实例的常规属性数组
                Object.getOwnPropertySymbol()返回对象实例的符号属性数组
                Object.getOwnPropertyDescriptors()返回同时包含常规和符号属性描述符的对象
                Reflect.ownKeys()返回两种类型的键
            -常用内置符号
                Symbol.asyncIterator：表示实现异步迭代器API的函数
                    for-await-of循环会利用这个函数执行异步迭代操作，循环时，它们会调用以Symbol.asyncIterator为键的函数，并期望这个函数返回一个实现迭代器API的对象
                    由Symbol.asyncIterator函数生成的对象应该通过其next()方法陆续返回Promise实例。可以显式调用next()方法返回也可以隐式通过异步生成器函数返回

                Symbol.hasInstance：表示一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例,由instance of操作符使用
                    instance of操作符可以用来确定一个对象实例的原型链上是否有原型

                Symbol.isConcatSpreadable:表示一个布尔值，如果是true，则对象应该用Array.prototype.concat()打平其数组元素，如果是false或假值会导致整个对象被追加到数组末尾
                    类数组对象默认情况下会被追加到数组末尾，true或真值会导致这个类数组对象被打平到数组实例，其他不适类数组对象的对象在Symbol.isConcatSpreadable被设置为true的情况下会被忽略

                Symbol.iterator：表示一个方法，该方法返回对象默认的迭代器，由for-of语句使用，表示实现迭代器API的函数
                    for-of循环这样的语言结构会利用这个函数执行迭代操作，循环时它们会调用以Symbol.iterator为键的函数，并默认这个函数返回一个实现迭代器API的对象

                Symbol.match：表示一个正则表达式方法，该方法用正则表达式去匹配字符串，由String.prototype.match()方法使用
                    String.prototype.match()方法会使用以Symbol.match为键的函数来对正则表达式求值
                
                Symbol.replace：表示一个正则表达式方法，该方法替换一个字符串匹配的子串，由String.prototype.replace()方法使用
            （7）Object类型
                对象通过new操作符后跟对象类型的名称来创建，ECMAScript只要求在给构造函数提供参数时使用括号，如果没有参数可以省略括号（不推荐）
                Object类型的所有属性和方法在派生的对象上同样存在：
                    constructor:用于创建当前对象的函数
                    hasOwnProperty(propertyName):用于判断当前对象实例上是否存在给定的属性，要检查的属性名必须是字符串
                    isPrototypeOf(object):用于判断当前对象是否为另一个对象的原型
                    PropertyIsEnumerable(propertyName):判断给定的属性是否可以使用for-in枚举，属性名必须是字符串
                    toLocaleString():返回对象的字符串表示，该字符串反映对象所在的本地化执行环境
                    toSring():返回对象的字符串表示
                    ValueOf():返回对象对应的字符串、数值或布尔值表示
操作符
    一元运算符
        递增/递减操作符：++和--
            前缀版与后缀版：
                前缀版变量的值都会在被求值之前改变
                后缀版变量在语句被求值后才发生
    位操作符
        ECMAScript中所有数值都以IEEE 754 64为格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数再进行位操作，之后再把结果转换为64位
        有符号整数使用32位的前31位表示整数值，第32位表示数值的符号，以0表示正，1表示负，这一位称为符号位，它的值决定了数值其余部分的格式。正值以真正的二进制格式存储；负值以一种称为二补数的二进制编码存储。一个数值的二补数通过以下步骤计算：
            ①确定绝对值的二进制表示
            ②找到数值的一补数（或反码）即每一个0变成1，,变成0
            ③给结果加1

        按位非
            按位非操作符用波浪符（~）表示，它的作用是返回数值的一补数，按位非最终效果是对数值取反并减一
        按位与
            按位与操作符用和号（&）表示，按位与就是将两个数的每一位对齐，然后在两个位都是1时返回1，在任何一位是0时返回0
        按位或
            按位或操作符用管道符（|）表示，按位或操作在至少一位是1时返回1，两位都是0时返回0
        按位异或
            按位异或用脱字符（^）表示，按位异或只在一位是1时返回1，其他情况返回0
            注意：这比对同样两个值执行按位或操作得到的结果小1
        左移
            左移操作符用两个小于号（<<）表示，会按照指定的位数将数值的所有位向左移动
            注意：左移会保留它所操作数值的符号
        有符号右移
            有符号右移由两个大于号（>>）表示，会将数值的所有32位向右移，同时保留符号，实际上是左移的逆运算
        无符号右移
            无符号右移用三个大于号（>>>）表示，会将数值的所有32位向右移，对于正数有无符号右移结果相同；对于负数，无符号右移会给空位补0，而不管符号位是什么
        
                

        

                    

                    











                

                        














 -->
