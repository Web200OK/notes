<meta charset = "utf-8" /> 告诉浏览器网页采用的编码字符集

<!DOCTYPE html>

- JPEG(JPG)：颜色多、不支持透明、图片可以压缩
- GIF：颜色少，支持动态图、支持简单的透明
- PNG：颜色最丰富的，支持复杂程度的透明

meta标签

- 告诉浏览器页面采用编码字符集
- 页面关键词
- 页面描述
- 页面重定向
- 适配移动端，设置视口大小与比例

选择器优先级

- 内联样式：1000
- id选择器：100
- 类、属性和伪类选择器：10
- 元素选择器和伪元素选择器：1
- 通配选择器：0
- 继承样式：没有优先级

font简写属性：大小和字体必须写，大小在倒数第二，字体在倒数第一

高度塌陷：子元素设置浮动后没办法撑开父元素宽度与高度

解决方案：

- 为父元素设置宽高（不能自动适应子元素宽高）
- 为父元素开启BFC：设置元素浮动（父元素宽度丢失）、设置绝对定位、设置元素为inline-block（父元素宽度丢失）、将overflow设置为非visible值
- 设置伪类元素:after并清除浮动

设置透明度：opacity（值0~1） IE8及以下：filter:alpha(opacity=值0~100)

数组常见增删方法：

- pop()：删除最后的数据
- push()：在最后增加数据
- shift()：删除第一个数据
- unshift()：在开头增加数据

- this指向：
  在函数调用就是window
- 在对象中以方法调用就是那个对象
- 在构造函数中调用就是创建的实例
- call、apply()就是指哪打哪

显式原型：prototype

隐式原型：`__proto__`

原型链

每一个函数声明后都会有创建一个prototype属性，称为显式原型，指向的是一个Object对象，当函数作为普通函数调用时该属性没什么用，当函数作为构造函数调用创建一个实例时，实例对象会有一个`__proto__`属性，称为隐式原型，指向的是构造函数的显式原型对象，实例可以使用原型对象上的函数，所以我们经常在原型对象上创建方法来提供给实例对象共同使用。当调用实例方法时，会先在自身上查找，如果没找到再在`__proto__`指向的对象上找，如果还找不到，就顺着`__proto__`链继续找，如果在Object的原型对象还找不到就返回undefined

事件代理

当我们需要对很多元素添加事件响应函数的时候，可以将事件添加在这些元素的父元素上委托父元素来触发处理函数，这得益于事件的冒泡机制。同时这样做还有一个好处，我们如果利用js动态添加子节点后就不需要再重新为元素绑定事件响应函数了。

call、apply与bind的区别

这三个都可以修改函数的this指向，call函数需要的第一个实参是要修改的this指向，第二个参数及以后是传递进去的实参；apply函数需要的第一个实参是要修改的this指向，第二个参数是传递一个参数数组，这两个函数都是立即调用，但bind不一样，bind函数的第一个实参是要修改的this指向，第二个参数及以后是传递进去的实参，但是它的返回值是一个函数以及接收的参数列表的使用，bind不会改变原函数的this，我们可以用一个变量来接收这个返回值再进行调用。

attribute与property的区别

- property是DOM的属性，是JS中的对象；attribute是HTML标签上的特性，它的值只能是字符串

- 对property可以赋任何类型的值；对attribute只能赋值字符串

- 对于修改，property能够从attribute中得到同步；但是attribute不可以，对任意一个中的值进行修改都会反映到HTML页面上

  
